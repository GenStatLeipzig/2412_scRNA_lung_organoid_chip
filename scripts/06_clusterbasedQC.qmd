---
title: "azimuth"
format:
  html:
    df-print: paged
    fig-width: 10
    fig-height: 7
    code-fold: true
    code-summary: "Show the code"
    toc: true
    toc-location: left
    toc-depth: 3
    number-sections: false
    standalone: true
    embed-resources: true
editor: source
execute:
  cache: false
editor_options:
  chunk_output_type: console
---

# INITITATE
  
```{r}
rm(list = setdiff(ls(), "seurat"))

# .libPaths("~/rpackages/angmar/")
.libPaths()

library(toolboxH)
library(Seurat)

library(here)
library(ggplot2)
library(scales)
library(ggthemes)
# BiocManager::install("scRNAseq")
library(BiocParallel)
library(patchwork)
# library(DropletUtils)
# library(celda)

require(gprofiler2)

# BiocManager::install("SingleR")

library(future) #https://satijalab.org/celllines/archive/v3.0/future_vignette.html
options(future.globals.maxSize= 30*1024^3) # to prevent the error
future.seed=TRUE # to care for proper random seeds
# The total size of the 15 globals exported for future expression ('FUN()') is 12.32 GiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). The three largest globals are 'object' (12.26 GiB of class 'numeric'), 'split.cells' (54.18 MiB of class 'list') and 'rowVars' (226.99 KiB of class 'function')
ncores = 4
plan("multicore", workers = ncores)
# initializeSkript()
initializeSkript()
options(scipen=999)
```

## special functions
```{r}
source(here("../../../07_programme/github/scRNATexMex/R/scRNA_functions_25-07-04git.R"))


```
# LOAD




```{r}
all10x = readRDS(here("results/05_1_seurat_celltypes_superliberalfiltered_gpt41.rds"))
all10x
all10x$run10x = all10x$sample
all10x$run10x %>% table()

anno_doublett = fread(here("results/04_scDBlFinder.txt.gz"))
qlist1 = venn2(anno_doublett$rn, colnames(all10x))

```

# add doublett information
The Key Outputs:
1. scDblFinder.class

Binary classification: singlet or doublet
The final decision - this cell is classified as either a single cell or two cells captured together

2. scDblFinder.score

The final doublet score (0-1)
Higher score = more likely to be a doublet
This is the main score used for thresholding
Generated by gradient boosted trees using multiple predictors

3. scDblFinder.weighted

Distance-weighted ratio of artificial doublets in the cell's k-nearest neighbors
One of the predictors used by the gradient boosted trees model
NOT a component of the final score, but a feature used to calculate it

4. scDblFinder.cxds_score

Co-expression Doublet Score (variant from the scds package)
Based on unusual co-expression patterns of mutually exclusive genes
Also a predictor used by the gradient boosted trees when use.cxds=TRUE
NOT a component of the final score, but a feature used to calculate it

How they relate:
Based on the documentation, here's the correct relationship:

scDblFinder uses gradient boosted trees to calculate the final score
The gradient boosted trees model uses multiple predictors including:

KNN-derived properties (including the weighted score)
Library size
Number of non-zero features
An estimate of difficulty detecting artificial doublets
If enabled, the cxds_score as an additional predictor


The score is the output of this gradient boosted trees model
The class is determined by applying a threshold to this score

```{r}
anno_doublett = fread(here("results/04_scDBlFinder.txt.gz"))
all10x$scDblFinder.class = anno_doublett[match_hk(colnames(all10x), anno_doublett$rn), scDblFinder.class]
all10x$scDblFinder.score = anno_doublett[match_hk(colnames(all10x), anno_doublett$rn), scDblFinder.score]
boxplot(all10x$scDblFinder.score ~ all10x$scDblFinder.class)


anno_all10x = all10x@meta.data %>% data.table(keep.rownames = TRUE)
```


# initial QC  ----
```{r}
# Plotting the QC metrics
all10x$run10x %>% table()
p_init_QC =plotQC(all10x,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = TRUE, dotplotcolor = "percent.mt")
p_init_QC 


p_init_QC_celltype =plotQC(all10x,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = TRUE, dotplotcolor = "percent.mt", splitBy = "celltype_chatti4_1_purcons")
p_init_QC_celltype 



p_init_QC_nolog =plotQC(all10x,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = FALSE, dotplotcolor = "percent.mt")
p_init_QC_nolog & theme(axis.text.x = element_text(angle = 45, hjust = 1)) & scale_y_continuous(breaks = pretty_breaks(10))
# filter for min nCount_RNA and nFeature_RNA
# all10x2 = subset(all10x, subset = nCount_RNA > 30 & nFeature_RNA > 30)
# 
# p_init_QC2 =plotQC(all10x2,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = TRUE, dotplotcolor = "percent.mt")
# p_init_QC2
# 
# anno_all10x[, removed_QC1 := rn %nin% colnames(all10x2)]
# # percentage per run10x
# anno_all10x[, .N, .(removed_QC1, run10x)]

(FeaturePlot(all10x, features = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), pt.size = 0.1)  + 
  theme(legend.position = "right") + 
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) & 
  scale_color_viridis_c()) +
  (DimPlot(all10x, group.by = "seurat_clusters", label = T) + NoLegend())  
```
# MAD based QC annotation
```{r}

# Split by run10x and calculate run10x-specific MADs
batch_specific_thresholds = lapply(unique(all10x$run10x), function(current_batch) {
  # Subset data for current run10x
  # current_batch = all10x$run10x[1]
  batch_cells <- rownames(all10x@meta.data[all10x$run10x == current_batch, ])
  batch_metrics <- data.table(
    nCount_RNA = all10x$nCount_RNA[batch_cells],
    nFeature_RNA = all10x$nFeature_RNA[batch_cells],
    percent.mt = all10x$percent.mt[batch_cells],
    percent.ribo = all10x$percent.ribo[batch_cells],
    doublett = all10x$scDblFinder.score[batch_cells]
  )
  
  # Calculate median and MAD for this run10x
  batch_metricsm = melt(batch_metrics, variable.name = "metric", value.name = "value")
  
  batch_stats <- batch_metricsm[, .(
    median = median(value, na.rm = TRUE),
    mad = mad(value, na.rm = TRUE)), metric]
  
  # Use same MAD ranges for all batches of the same tissue
  batch_stats[, `:=`(
    lower_threshold = ifelse(metric %in% c("nCount_RNA", "nFeature_RNA", "percent.ribo"), 
                            median - (mad * 6), NA),
    upper_threshold = ifelse(metric %in% c("nCount_RNA", "nFeature_RNA"), 
                            median + (mad * 6),
                            ifelse(metric == "percent.mt", 
                                  median + (mad * 5), 
                                  median + (mad * 5)))
  )]
  
  cbind(run10x = current_batch, batch_stats)
}) %>% rbindlist(fill = TRUE)


batch_specific_thresholds2 = dcast.data.table(
  batch_specific_thresholds,
  run10x ~ metric,
  value.var = c("lower_threshold", "upper_threshold")
) 
setcolorder(batch_specific_thresholds2, c("run10x",  "lower_threshold_nCount_RNA", "upper_threshold_nCount_RNA", "lower_threshold_nFeature_RNA", "upper_threshold_nFeature_RNA", "lower_threshold_percent.mt", "upper_threshold_percent.mt"))
batch_specific_thresholds2
# Flag cells based on run10x-specific thresholds
cells_to_keep <- c()

for (current_batch in unique(all10x$run10x)) {
  batch_cells <- rownames(all10x@meta.data[all10x$run10x == current_batch, ])
  thresholds <- batch_specific_thresholds[run10x ==current_batch]
  
  batch_keep <- batch_cells[
    all10x$nCount_RNA[batch_cells] >= 100 &
    all10x$nCount_RNA[batch_cells] <= 100000 &
    all10x$nFeature_RNA[batch_cells] >= 100 &
    all10x$nFeature_RNA[batch_cells] <= 10000 &
    all10x$percent.mt[batch_cells] <= 30 &
      all10x$scDblFinder.class[batch_cells] == "singlet"
      #thresholds[metric == "percent.mt"]$upper_threshold 
    # &
    # all10x$percent.ribo[batch_cells] >= thresholds[metric == "percent.ribo"]$lower_threshold &
    # all10x$percent.ribo[batch_cells] <= thresholds[metric == "percent.ribo"]$upper_threshold
  ]
  
  cells_to_keep <- c(cells_to_keep, batch_keep)
}

# Annotate the Seurat object
anno_all10x[, QC1 := rn %in% cells_to_keep]
qcfilt1 = anno_all10x[, .N, .(QC1, run10x)]
# show as barplot with percentag on top of each bar
qcfilt1[, Nproz := N / sum(N) * 100, run10x]
qcfilt1[, Nproz := round(Nproz)]
qcfilt1[, Nproz2 := paste0(N, " (", Nproz, "%)")]


p_qc1 = ggplot(qcfilt1, aes(x = run10x, y = N, fill = QC1)) +
  geom_bar(stat = "identity", position = "stack") +
  theme_minimal(base_size = 24) +
  labs(title = "QC1: Filtered cells per run10x", fill = "QC ok") +
  # scale_fill_manual(values = c("red", "blue")) +
  scale_fill_tableau()+
  geom_text(aes(label = Nproz2), position = position_stack(vjust = 0.5)) +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
p_qc1

```

# show cluster-wise percentage of QC ok cells
```{r}
plotdat_clust = anno_all10x[,.N, .(seurat_clusters, celltype_chatti4_1_purcons , bad_cell=QC1==FALSE, bad_mito = percent.mt>25, doublet = scDblFinder.class!="singlet")][order(celltype_chatti4_1_purcons)]

plotdat_clust[,.N, .(bad_cell, bad_mito, doublet)]

p_cluster = ggplot(plotdat_clust, aes(x = seurat_clusters %>% as.character(), y = N, fill = bad_cell)) +
  geom_bar(stat = "identity", position = "fill") + 
  scale_fill_manual(values = c("grey", "red")) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1), 
        strip.text.x = element_text(angle = 90, hjust = 0)) +
  labs(
       x = "Cluster", y = "Cells failing QC") +
  scale_y_continuous(labels = label_percent(accuracy = 1), breaks = pretty_breaks(10))+
  theme(legend.position = "none") + 
  # scale_x_continuous(breaks = pretty_breaks(2)) +
  facet_grid(.~ celltype_chatti4_1_purcons, scales = "free", space = "free") + 
  geom_hline(yintercept = 0.5, linewidth = 1,linetype = "dashed", color = "purple") +
  geom_text(data = plotdat_clust[bad_cell ==FALSE, .( bad_cell,N = sum(N)), .(seurat_clusters,celltype_chatti4_1_purcons)] %>% unique(), aes(label = paste("ok",N)), position = position_fill(vjust = 0.55), size = 3, angle = 90, col = "black")+

  geom_text(data = plotdat_clust[bad_mito ==TRUE, .( bad_cell=T,N = sum(N)), .(seurat_clusters,celltype_chatti4_1_purcons)]%>% unique(), aes(label = paste("Mito",N)), position = position_fill(vjust = 0.95), size = 3, angle = 90, col = "darkred") +
    geom_text(data = plotdat_clust[doublet ==TRUE, .(bad_cell=T, N = sum(N)), .(seurat_clusters,celltype_chatti4_1_purcons)]%>% unique(), aes(label = paste("Doub",N)), position = position_fill(vjust = 0.75), size = 3, angle = 90, col = "darkred") 


p_cluster
```



# filter
```{r}
plotdat_clust2 = plotdat_clust[, .(prozbad = sum(N[bad_cell ==T]) / sum(N) * 100), seurat_clusters    ][order(prozbad)]
plotdat_clust2
bad_cluster = plotdat_clust2[prozbad>50, seurat_clusters]

all10x2 = all10x[, all10x$seurat_clusters %nin% bad_cluster &
                   all10x$scDblFinder.class =="singlet" &
                   all10x$percent.mt <30]

p_init_QC2 =plotQC(all10x2,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = TRUE, dotplotcolor = "percent.mt")
p_init_QC2 


p_init_QC_celltype2 =plotQC(all10x2,qccols = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), plotlog = TRUE, dotplotcolor = "percent.mt", splitBy = "celltype_chatti4_1_purcons")
p_init_QC_celltype2 

```


# show markerplot supporting celltypes
```{r}
lung_markers <- rbind(
  data.table(celltype = "Basal epithelial", markers = c("KRT5", "TP63", "EGFR", "KRT14")),  # KRT5/TP63 are canonical markers
  data.table(celltype = "Type 2 alveolar", markers = c("SFTPC", "SFTPB", "SFTA2", "NAPSA")),  # SFTPC is canonical specific marker
  data.table(celltype = "Type 1 alveolar", markers = c("AGER", "HOPX", "CADM1", "RBMS3")),  # AGER is canonical specific marker
  data.table(celltype = "Club", markers = c("SCGB1A1", "CYP2B7P", "TMC5", "NEBL")),  # SCGB1A1 is canonical but not in data
  data.table(celltype = "Endothelial", markers = c("CDH5", "ERG", "CALCRL", "TIE1")),  # CDH5 is canonical specific marker
  data.table(celltype = "Fibroblasts", markers = c("VIM", "LGALS1", "COL1A1", "FABP5")),  # VIM/COL1A1 are canonical
  data.table(celltype = "Epithelial", markers = c("EPCAM", "KRT8", "KRT19", "CDH1"))  # EPCAM is canonical specific marker
)

# Create species-specific plots - Basic version
marker_plot_basic <- doMarkerDotPlot(seurat = all10x2, 
                                     marker_groups_peter = lung_markers, 
                                     grouping_factor = 'celltype_chatti4_1_purcons'
) 

marker_plot_basic2 <- doMarkerDotPlot(seurat = all10x2, 
                                     marker_groups_peter = lung_markers, 
                                     grouping_factor = 'celltype_chatti4_1_purcons',custom_y_axis = c("Endothelial Cells", "Alveolar Type II (ATII) Cells", "Alveolar Type I (ATI) Cells", "Basal Epithelial Cells", "Epithelial Cells", 
"Unknown"
)
                                     
) 
 
```
```{r}
DimPlot(all10x2, group.by = "celltype_chatti4_1_purcons", label = T) + NoLegend() 
anno_all10x2 = all10x2@meta.data %>% data.table(keep.rownames = TRUE)
ggplotSankey(anno_all10x2[,.(celltype_chatti4_1_purcons, sample )])
```

# repeat clustering with filtered and higher level
```{r}
# Now process the combined object as needed
all10x3 = DietSeurat(all10x2, layers = "count")
## delete data and scale.date slot
all10x3[["RNA"]]$data <- NULL
all10x3[["RNA"]]$scale.data <- NULL

all10x3[["RNA"]] <- split(all10x3[["RNA"]], f = all10x3$run10x)
all10x3

all10x3 <- NormalizeData(all10x3)
all10x3 <- FindVariableFeatures(all10x3)
all10x3 <- ScaleData(all10x3)
all10x3 <- RunPCA(all10x3)

# Add clustering
all10x3 <- FindNeighbors(all10x3, dims = 1:30, reduction = "pca")

all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "unintegrated_clusters")
all10x3 <- RunUMAP(all10x3, dims = 1:30, reduction = "pca", reduction.name = "umap.unintegrated")

Reductions(all10x3)



p_unintegrated=DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "unintegrated_clusters"), label = T, reduction = "umap.unintegrated") + plot_annotation(title = "Unintegrated merged data")& NoLegend()  
p_unintegrated



# Visualization


VlnPlot(all10x3, features = c("nCount_RNA", "nFeature_RNA", "percent.mt", "percent.ribo", "scDblFinder.score"), pt.size = 0, group.by = 'unintegrated_clusters')


# anno_all10x2fine = all10x3@meta.data %>% data.table(keep.rownames = TRUE)


```


# integration
```{r}
# ## Integrated merged , 5 variants----
# https://satijalab.org/seurat/articles/seurat5_integration

options(future.globals.maxSize = 10e+09)
options('future.globals.maxSize')
require(SeuratWrappers) # for FastMNNIntegration and scvi integration

DefaultAssay(all10x3)


all10x3 <- IntegrateLayers(
  object = all10x3, method = RPCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.rpca",
  verbose = TRUE
)

all10x3 <- FindNeighbors(all10x3, reduction = "integrated.rpca", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "rpca_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "integrated.rpca", dims = 1:30, reduction.name = "umap.rpca")

p_rpca = DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "rpca_clusters"), label = T, reduction = "umap.rpca") + plot_annotation(title = "rpca Integrated merged data")& NoLegend()  
p_rpca



all10x3 <- IntegrateLayers(
  object = all10x3, method = HarmonyIntegration,
  orig.reduction = "pca", new.reduction = "harmony",
  verbose = TRUE
)
all10x3 <- FindNeighbors(all10x3, reduction = "harmony", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "harmony_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "harmony", dims = 1:30, reduction.name = "umap.harmony")


p_harmony = DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "harmony_clusters"), label = T, reduction = "umap.harmony") + plot_annotation(title = "harmony Integrated merged data")& NoLegend()  
p_harmony



all10x3 <- IntegrateLayers(
  object = all10x3, method = scVIIntegration,
  new.reduction = "integrated.scvi",
  conda_env = "C:/Users/hol7525kir/AppData/Local/r-miniconda/envs/scvi-env", verbose = TRUE ) # from windows anaconda prompt, befehl  conda info --envs, dann conda activate C:/Users/hol7525kir/AppData/Local/r-miniconda, dann pip install scvi-tools, dann update SeuratWrappers  . On server disc not possible filename too long


all10x3 <- FindNeighbors(all10x3, reduction = "integrated.scvi", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "scvi_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "integrated.scvi", dims = 1:30, reduction.name = "umap.scvi")


p_scvi= DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "scvi_clusters"), label = T, reduction = "umap.scvi") + plot_annotation(title = "scvi Integrated merged data")& NoLegend()  
p_scvi




all10x3 <- IntegrateLayers(
  object = all10x3, method = FastMNNIntegration,
  new.reduction = "integrated.mnn",
  verbose = TRUE
) # not available, also not on github https://raw.githubusercontent.com/satijalab/seurat/1549dcb3075eaeac01c925c4b4bb73c73450fc50/R/integration5.R, also scVIIntegration not available any more

all10x3 <- FindNeighbors(all10x3, reduction = "integrated.mnn", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "mnn_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "integrated.mnn", dims = 1:30, reduction.name = "umap.mnn")
 
p_fmnn = DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "mnn_clusters"), label = T, reduction = "umap.mnn") + plot_annotation(title = "fast mnn Integrated merged data")& NoLegend()  
p_fmnn





all10x3 <- IntegrateLayers(
  object = all10x3, method = JointPCAIntegration,
  new.reduction = "integrated.jpca",verbose = TRUE
)


all10x3 <- FindNeighbors(all10x3, reduction = "integrated.jpca", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "jpca_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "integrated.jpca", dims = 1:30, reduction.name = "umap.jpca")

 
p_jpca= DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "jpca_clusters"), label = T, reduction = "umap.jpca") + plot_annotation(title = "jpca Integrated merged data")& NoLegend()  
p_jpca




all10x3 <- IntegrateLayers(
  object = all10x3, method = CCAIntegration,
  orig.reduction = "pca", new.reduction = "integrated.cca",
  verbose = TRUE
)


all10x3 <- FindNeighbors(all10x3, reduction = "integrated.cca", dims = 1:30)
all10x3 <- FindClusters(all10x3, resolution = 1, cluster.name = "cca_clusters")
all10x3 <- RunUMAP(all10x3, reduction = "integrated.cca", dims = 1:30, reduction.name = "umap.cca")

p_cca= DimPlot(all10x3, group.by = c('sample',"celltype_chatti4_1_purcons", "cca_clusters"), label = T, reduction = "umap.cca") + plot_annotation(title = "cca Integrated merged data")& NoLegend()  
p_cca






```


 
 # repeat differntial expression for celltype alignment
```{r}
Idents(all10x3) = all10x3$scvi_clusters
Idents(all10x3) %>% mytable()

all10x4 = JoinLayers(all10x3)
cellmarkers <- FindAllMarkers(all10x4, only.pos = FALSE, min.pct = 0.2, logfc.threshold = 0.08)
# ltnkcells_top_markers <- cellmarkers %>% group_by(cluster) %>% top_n(10, avg_log2FC)
setDT(cellmarkers)


# cellmarkers[, fullname := get_full_gene_names(gene)]


# chati ----
gptcelltype_hk <- function(input, tissuename=NULL, model='gpt-4', topgenenumber = 10, 
                           include_downreg = TRUE) {
  OPENAI_API_KEY <- Sys.getenv("OPENAI_API_KEY")
  if (OPENAI_API_KEY == "") {
    print("Note: OpenAI API key not found: returning the prompt itself.")
    API.flag <- 0
  } else {
    API.flag <- 1
  }
  
  if (class(input)=='list') {
    input <- sapply(input,paste,collapse=',')
  } else {
    # Create separate lists for upregulated and downregulated genes
    up_input <- input[input$avg_log2FC > 0,,drop=FALSE]
    up_genes <- tapply(up_input$gene, list(up_input$cluster), 
                       function(i) paste0(i[1:min(topgenenumber, length(i))], collapse=','))
    
    # Process downregulated genes if requested
    if (include_downreg) {
      down_input <- input[input$avg_log2FC < 0,,drop=FALSE]
      down_genes <- tapply(down_input$gene, list(down_input$cluster), 
                           function(i) paste0(i[1:min(topgenenumber, length(i))], collapse=','))
      
      # Create formatted input for each cluster
      formatted_input <- character(0)
      all_clusters <- unique(c(names(up_genes), names(down_genes)))
      
      for (cluster in all_clusters) {
        up_str <- if (cluster %in% names(up_genes)) up_genes[cluster] else ""
        down_str <- if (cluster %in% names(down_genes)) down_genes[cluster] else ""
        formatted_input[cluster] <- paste0("UP[", up_str, "] DOWN[", down_str, "]")
      }
    } else {
      # Use only upregulated genes if downregulated genes are not requested
      formatted_input <- paste0("UP[", up_genes, "] DOWN[]")
      names(formatted_input) <- names(up_genes)
    }
    
    input <- formatted_input
  }
  
  # Create the prompt header
  prompt_header <- paste0('Identify cell types of ', tissuename, ' cells using the following markers for each row representin a cluster of cells in a Seurat scRNA-seq analysis. ',
                          'Each row representing the cluster starts with a certain number as ID for this cluster and a colon, followed by genes differentially expressed in this cluster vs. the others, provided in two categories:\n',
                          '1. Upregulated genes are shown in brackets after "UP" (e.g., UP[Gene1,Gene2,Gene3])\n',
                          '2. Downregulated genes are shown in brackets after "DOWN" (e.g., DOWN[Gene4,Gene5,Gene6])\n\n',
                          'Only provide the cell type name. Do show cluster number and a colon before the name. If you do not find a celltype, return "Unknown". Return the same number of rows as the number of clusters provided as input\n ',
                          'Some clusters can be a mixture of multiple cell types.\n\n')
  
  # Generate full prompt with all genes included
  full_prompt <- paste0(prompt_header, paste0(names(input), ': ', unlist(input), collapse = '\n'))
  
  # Always print the full prompt for copying to online LLM
  print("Complete prompt (copy this to test with an online LLM):")
  cat(full_prompt)
  
  if (!API.flag){
    return(full_prompt)
  } else {
    print("Note: OpenAI API key found: returning the cell type annotations.")
    
    cutnum <- ceiling(length(input)/50)
    if (cutnum > 1) {
      cid <- as.numeric(cut(1:length(input),cutnum))	
      print(paste0("Note: Due to the number of clusters (", length(input), "), the API request will be split into ", 
                   cutnum, " batches."))
    } else {
      cid <- rep(1,length(input))
    }
    
    allres <- list()
    
    for (i in 1:cutnum) {
      # i=1
      id <- which(cid==i)
      
      # Generate batch-specific prompt
      batch_prompt <- paste0(prompt_header, paste0(names(input)[id], ': ', input[id], collapse = '\n'))
      
      # For each batch, print which clusters are included
      cat(paste0("Batch ", i, " includes clusters: ", paste(names(input)[id], collapse=", ")))
      
      # Use tryCatch to handle potential errors without looping
      result <- tryCatch({
        k <- openai::create_chat_completion(
          model = model,
          message = list(list("role" = "user", "content" = batch_prompt))
        )
        
        res <- strsplit(k$choices[,'message.content'],'\n')[[1]]
        
        # Check if we have the right number of results
        if (length(res) != length(id)) {
          warning(paste("Expected", length(id), "results, but got", length(res), 
                        "- the model response may be incomplete or incorrectly formatted."), immediate. = TRUE )
        }
        
        names(res) <- names(input)[id]
        res
      }, error = function(e) {
        # Print the error message and return NULL instead of retrying
        print(paste("Error in API call for batch", i, ":", e$message))
        print("Suggestion: Try reducing the number of genes per cluster or clusters per batch.")
        return(res)
      })
      
      if (!is.null(result)) {
        allres[[i]] <- result
      } else {
        print(paste("Batch", i, "failed. Continuing with next batch if available."))
      }
    }
    
    # Combine results from successful batches
    if (length(allres) > 0) {
      final_results <- gsub(',$', '', unlist(allres))
      print('Note: It is always recommended to check the results returned by GPT-4 in case of\n AI hallucination, before going to down-stream analysis.')
      return(final_results)
    } else {
      print("All API calls failed. Please check error messages above.")
      return(NULL)
    }
  }
}

# Sys.setenv(OPENAI_API_KEY = 'your_openai_API_key')


markers_sign = cellmarkers[cellmarkers$p_val_adj <=0.05,] %>% as.data.table(keep.rownames = T)
markers_sign$cluster %>% table() %>% sort(decreasing = T)  

markers_sign = markers_sign[grepl("Rp", gene)==FALSE]

markers_sign[markers_sign$avg_log2FC >0,"cluster"] %>% table() %>% sort(decreasing = T)  
markers_sign[markers_sign$avg_log2FC <0,"cluster"] %>% table() %>% sort(decreasing = T)  

setDF(markers_sign)

# Sys.setenv(OPENAI_API_KEY = 'your_openai_API_key')

if(file.exists(here("results/06_chatti_celltypes_gpt41_scvi"))==FALSE) {
  
  res_gpt4omini_30_ud <- gptcelltype_hk(input = markers_sign,tissuename = "Human  Epithelial and Endothelial cells", topgenenumber = 30, model = 'gpt-4o-mini', include_downreg=T) # less than one cent
  
  res_gpt4omini_30_ud
  
  # res_gpt4.1_30_ud <- gptcelltype_hk(input = markers_sign,tissuename = "Human Epithelial and Endothelial cells", topgenenumber = 30, model = 'gpt-4.1', include_downreg=TRUE) # 
  
  res_gpt4.1_30_ud
  
  chatti = data.table(
    res_gpt4.1_30_ud = res_gpt4.1_30_ud %>% str_trim(),
    res_gpt4omini_30_ud=res_gpt4omini_30_ud %>% str_trim(),
    celltypenum = names(res_gpt4.1_30_ud)%>% str_trim())
  chatti
  
  # celltype_df = data.table(celltypenunm  = factor(all10x4$rs_aortamarker_250328v4renamed) %>% as.numeric(),
  #                          celltype  = factor(all10x4$rs_aortamarker_250328v4renamed) %>% as.character()) %>% unique()
  # 
  # 
  # chatti[, celltypename := celltype_df[match_hk(chatti$celltypenum, celltype_df$celltypenunm), celltype]]
  fwrite(chatti, here("results/06_chatti_celltypes_gpt41_scvi"), sep = "\t")
} else chatti = fread(here("results/06_chatti_celltypes_gpt41_scvi"))
chatti


all10x4$celltype_chatti4_1_v2_scvi = chatti[match_hk(all10x4$scvi_clusters, chatti$celltypenum), res_gpt4.1_30_ud ]
all10x4$celltype_chatti4_1_v2_scvi %>% mytable()

anno_all10x4 = all10x4@meta.data %>% data.table(keep.rownames = TRUE)

anno_all10x4[, celltype_chatti4_1_v2_scvi := chatti[match_hk(anno_all10x4$scvi_clusters, chatti$celltypenum), res_gpt4.1_30_ud ]]


all10x4$celltype_chatti4_1_v2_scvi_pur = str_split(all10x4$celltype_chatti4_1_v2_scvi, "\\:") %>% sapply("[", 2) %>% str_trim()
all10x4$celltype_chatti4_1_v2_scvi_pur %>% mytable()


anno_all10x4[, celltype_chatti4_1_v2_scvi_pur := str_split(celltype_chatti4_1_v2_scvi, "\\:") %>% sapply("[", 2) %>% str_trim()]
anno_all10x4[, .N,celltype_chatti4_1_v2_scvi_pur]


ggplotSankey(anno_all10x4[,.(sample, celltype_chatti4_1_v2_scvi)])
ggplotSankey(anno_all10x4[,.(celltype_chatti4_1_v2_scvi, sample )])
ggplotSankey(anno_all10x4[,.(scvi_clusters, celltype_chatti4_1_v2_scvi )])
sort(unique(anno_all10x4$celltype_chatti4_1_v2_scvi_pur))
ggplotSankey(anno_all10x4[,.(celltype_chatti4_1_v2_scvi_pur, sample )]) +

DimPlot(all10x4, group.by = "celltype_chatti4_1_v2_scvi_pur", label = T, repel = T, reduction = "umap.scvi") &NoLegend() 

 



```




 
# rpca differntial expression for celltype alignment
```{r}
Idents(all10x3) = all10x3$rpca_clusters
Idents(all10x3) %>% mytable()
identical(Idents(all10x3) , all10x3$rpca_clusters)
all10x4 = JoinLayers(all10x3)
cellmarkers <- FindAllMarkers(all10x4, only.pos = FALSE, min.pct = 0.25, logfc.threshold = 0.1)
# ltnkcells_top_markers <- cellmarkers %>% group_by(cluster) %>% top_n(10, avg_log2FC)
setDT(cellmarkers)


# cellmarkers[, fullname := get_full_gene_names(gene)]

markers_sign = cellmarkers[cellmarkers$p_val_adj <=0.05,] %>% as.data.table(keep.rownames = T)
markers_sign$cluster %>% table() %>% sort(decreasing = T)  

markers_sign = markers_sign[grepl("Rp", gene)==FALSE]

markers_sign[markers_sign$avg_log2FC >0,"cluster"] %>% table() %>% sort(decreasing = T)  
markers_sign[markers_sign$avg_log2FC <0,"cluster"] %>% table() %>% sort(decreasing = T)  

setDF(markers_sign)

# Sys.setenv(OPENAI_API_KEY = 'your_openai_API_key')

if(file.exists(here("results/06_chatti_celltypes_gpt41_rpca"))==FALSE) {
  
  res_gpt4omini_30_ud <- gptcelltype_hk(input = markers_sign,tissuename = "Human  Epithelial and Endothelial cells", topgenenumber = 30, model = 'gpt-4o-mini', include_downreg=T) # less than one cent
  
  res_gpt4omini_30_ud
  
  # res_gpt4.1_30_ud <- gptcelltype_hk(input = markers_sign,tissuename = "Human Epithelial and Endothelial cells", topgenenumber = 30, model = 'gpt-4.1', include_downreg=TRUE) # 
  
  res_gpt4.1_30_ud
  
  chatti = data.table(
    res_gpt4.1_30_ud = res_gpt4.1_30_ud %>% str_trim(),
    # res_gpt4omini_30_ud=res_gpt4omini_30_ud %>% str_trim(),
    celltypenum = names(res_gpt4.1_30_ud)%>% str_trim())
  chatti
  
  # celltype_df = data.table(celltypenunm  = factor(all10x4$rs_aortamarker_250328v4renamed) %>% as.numeric(),
  #                          celltype  = factor(all10x4$rs_aortamarker_250328v4renamed) %>% as.character()) %>% unique()
  # 
  # 
  # chatti[, celltypename := celltype_df[match_hk(chatti$celltypenum, celltype_df$celltypenunm), celltype]]
  fwrite(chatti, here("results/06_chatti_celltypes_gpt41_rpca"), sep = "\t")
} else chatti = fread(here("results/06_chatti_celltypes_gpt41_rpca"))
chatti


all10x4$celltype_chatti4_1_v2_rpca = chatti[match_hk(all10x4$rpca_clusters, chatti$celltypenum), res_gpt4.1_30_ud ]
all10x4$celltype_chatti4_1_v2_rpca %>% mytable()

anno_all10x4 = all10x4@meta.data %>% data.table(keep.rownames = TRUE)

anno_all10x4[, celltype_chatti4_1_v2_rpca := chatti[match_hk(anno_all10x4$rpca_clusters, chatti$celltypenum), res_gpt4.1_30_ud ]]


all10x4$celltype_chatti4_1_v2_rpca_pur = str_split(all10x4$celltype_chatti4_1_v2_rpca, "\\:") %>% sapply("[", 2) %>% str_trim()
all10x4$celltype_chatti4_1_v2_rpca_pur %>% mytable()


anno_all10x4[, celltype_chatti4_1_v2_rpca_pur := str_split(celltype_chatti4_1_v2_rpca, "\\:") %>% sapply("[", 2) %>% str_trim()]
anno_all10x4[, .N,celltype_chatti4_1_v2_rpca_pur]


ggplotSankey(anno_all10x4[,.(sample, celltype_chatti4_1_v2_rpca)])
ggplotSankey(anno_all10x4[,.(celltype_chatti4_1_v2_rpca, sample )])
ggplotSankey(anno_all10x4[,.(rpca_clusters, celltype_chatti4_1_v2_rpca )])
ggplotSankey(anno_all10x4[,.(sample, celltype_chatti4_1_v2_rpca_pur)])+
ggplotSankey(anno_all10x4[,.(celltype_chatti4_1_purcons, celltype_chatti4_1_v2_rpca_pur )]) +
ggplotSankey(anno_all10x4[grepl("Unknown",celltype_chatti4_1_v2_rpca_pur),.(celltype_chatti4_1_purcons, celltype_chatti4_1_v2_rpca )])


FeaturePlot(all10x4,features = "scDblFinder.score", reduction = "umap.rpca") + VlnPlot(all10x4,features = "scDblFinder.score", group.by =  "rpca_clusters", pt.size = 0.01, alpha = 0.1)


  sort(unique(anno_all10x4$celltype_chatti4_1_v2_rpca_pur))
(ggplotSankey(anno_all10x4[,.(celltype_chatti4_1_v2_rpca_pur, sample )]) + guides(fill = "none", col = "none"))+

(DimPlot(all10x4, group.by = "celltype_chatti4_1_v2_rpca_pur", label = T, repel = T, reduction = "umap.rpca") ) & NoLegend()

 



```




```{r}
# Create species-specific plots - Basic version
marker_plot_basic_v2 <- doMarkerDotPlot(seurat = all10x4, 
                                     marker_groups_peter = lung_markers, 
                                     grouping_factor = 'celltype_chatti4_1_v2_rpca',
                                     custom_y_axis = 
                                     c("11: Endothelial cells", "12: Endothelial cells", "7: Endothelial cells", "10: Epithelial cells (Luminal, possible secretory/absorptive, i.e., glandular-like, MUC1+, CLDN7+, EPCAM+)", "14: Epithelial cells (Simple/luminal, KRT7+/KRT8+, CEACAM6+)", 

"8: Epithelial cells (Luminal, likely glandular/absorptive, CLDN7+, EPCAM+, LSR+)",
"3: Alveolar Type II cells", "1: Alveolar Type II cells", "2: Alveolar Type II cells", 
"5: Alveolar Type II cells", "13: Unknown", "4: Basal Epithelial cells", 
 
"9: Unknown", "0: Basal Epithelial cells", "6: Epithelial cells (Non-basal, cell-junction and cytoskeletal, likely intermediate/differentiating)"
)
) 

```


# Save
save allso findalmarkerlis
```{r}
fwrite(anno_all10x4, here("results/06_1_anno_all10x4_celltypes_qced_integrated.txt.gz"), sep = "\t")
saveRDS(all10x4, here("results/06_1_all10x4_celltypes_qced_integrated.rds"))

get_full_gene_names <- function(gene_symbols, organism = "mouse") {
   
  input = data.table(gene_symbols)
    input[, initialorder := .I]
    
  
  if(organism == "mouse") {
    
  library(org.Mm.eg.db)
  results <- select(org.Mm.eg.db, keys = gene_symbols, columns = c("SYMBOL", "GENENAME"), keytype = "SYMBOL") |> 
      data.table(keep.rownames = FALSE)
  results2 = results[is.na(GENENAME)==FALSE,.(GENENAME=paste(GENENAME, collapse = " /// alternative_fullname:,")), by = SYMBOL]
    
  input[, GENENAME := results2[match_hk(input$gene_symbols, results2$SYMBOL), GENENAME]]
    
    return(input$GENENAME)
  
  } else if(organism == "human") {
    library(org.Hs.eg.db)
   
    results <- select(org.Hs.eg.db, keys = unique(gene_symbols), columns = c("SYMBOL", "GENENAME"), keytype = "SYMBOL") |> 
      data.table(keep.rownames = FALSE)
    
    results2 = results[is.na(GENENAME)==FALSE,.(GENENAME=paste(GENENAME, collapse = " /// alternative_fullname:,")),  SYMBOL]
  
    input[, GENENAME := results2[match_hk(input$gene_symbols, results2$SYMBOL), GENENAME]]
    
    return(input$GENENAME)
  } else {
    stop("Unsupported organism. Please use 'mouse' or 'human'.")
  }
  
}


cellmarkers[, fullname := get_full_gene_names(gene_symbols = gene, organism = "human")]
cellmarkers[,cluster := as.numeric(as.character(cluster))]
setcolorder(cellmarkers, "cluster")

writexl::write_xlsx(list(cellmarkers_rpca = cellmarkers), here("results/06_1_cellmarkers_rpca_clust.xlsx"))
```

# finalize
```{r}
finalizeSkript()
```
